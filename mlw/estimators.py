import random
from collections import defaultdict

import networkx as nx
import numpy as np

from mlw.bp import LoopyBP
from mlw.mcmc import IsingMCMC

INFECTED = -1
SUSCEPTIBLE = 1


def generate_configuration(graph, p_matrix, num_malicious, iterations=50):
    """Generate a random system configuration."""
    nodes = list(graph.nodes)
    states = np.random.choice([INFECTED, SUSCEPTIBLE], size=len(nodes))
    init_states = {}
    fields = {}
    for node, state in zip(nodes, states):
        init_states[node] = state
        fields[node] = 0

    hosts, domains = nx.bipartite.sets(graph)
    assert len(domains) > len(hosts)

    # Popular domains are more difficult malware targets, so we add a positive
    # field to them based on their popularity.
    for node, degree in graph.degree(domains):
        fields[node] = np.log(degree)

    # We have some malicious actors.
    malicious = random.sample(domains, num_malicious)
    for node in malicious:
        fields[node] = -np.inf

    J = 0.5 * np.log(p_matrix[INFECTED, SUSCEPTIBLE]
                     / p_matrix[SUSCEPTIBLE, INFECTED])

    sim = IsingMCMC(graph, interaction=J, fields=fields, temperature=100)
    states, energies = sim.run(init_states, iterations)

    return states, energies


def estimate_accuracy(graph, p_matrix, known_hosts,
                      num_malicious=50, average_on=10):
    acc = []
    for _ in range(average_on):
        # Generate a random system configuration.
        conf, _ = generate_configuration(graph, p_matrix, num_malicious)

        # Evaluate accuracy
        hosts, domains = nx.bipartite.sets(graph)

        prior = defaultdict(lambda: {INFECTED: 0.5, SUSCEPTIBLE: 0.5})

        # We know the state of some host.
        known = random.sample(hosts, known_hosts)
        for node in known:
            prior[node] = {INFECTED: float(conf[node] == INFECTED),
                           SUSCEPTIBLE: float(conf[node] == SUSCEPTIBLE)}

        # We have some prior on popular domains.
        degrees = dict(graph.degree(domains))
        popular = sorted(degrees.keys(), key=degrees.get, reverse=True)[:50]
        max_degree = degrees[popular[0]]
        for node in popular:
            p = 1 / (1 + np.exp(- 2 * degrees[node] / max_degree))
            prior[node] = {INFECTED: 1 - p, SUSCEPTIBLE: p}

        # Run the max-product belief propagation
        bp = LoopyBP(graph, p_matrix, prior, [SUSCEPTIBLE, INFECTED])
        score = bp.run(reduce_func=max, tol=1e-6)

        correct_guesses = 0
        for node in domains:
            inferred = max(score[node].keys(), key=(lambda key: score[node][key]))
            correct_guesses += inferred == conf[node]

        acc.append(correct_guesses / len(domains))


    return np.mean(acc)
