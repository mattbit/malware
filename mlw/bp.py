from collections import defaultdict

import networkx as nx
import numpy as np


class LoopyBP:

    def __init__(self, graph, interaction, prior, domain):
        self.graph = graph
        self.phi = interaction
        self.h = prior
        self.domain = domain
        self.msg = defaultdict(lambda: {s: 1 for s in domain})

    def run(self, reduce_func=None, tol=.001):
        if reduce_func is None:
            reduce_func = sum

        err = np.inf
        while err > tol:
            err = 0

            for (i, j) in self.graph.edges:
                deltas = self._update_msgs(i, j, reduce_func)
                err = max(err, *deltas)

            for (i, j) in self.graph.edges:
                deltas = self._update_msgs(j, i, reduce_func)
                err = max(err, *deltas)

        return self._get_score()

    def _compute_msg(self, i, j, x_j, reduce_func):
        ns = {*list(self.graph.neighbors(i))} - {j}  # neighbors except j
        terms = []
        for x_i in self.domain:
            h = self.h[i][x_i] * np.product([self.msg[k, i][x_i] for k in ns])
            terms.append(self.phi(x_i, x_j) * h)

        return reduce_func(terms)

    def _update_msgs(self, i, j, reduce_func):
        msgs = {}
        for x_j in self.domain:
            msgs[x_j] = self._compute_msg(i, j, x_j, reduce_func)

        norm = sum(msgs.values()) / len(self.domain)
        delta = []
        for x_j in self.domain:
            old_msg = self.msg[i, j][x_j]
            self.msg[i, j][x_j] = msgs[x_j] / norm
            delta.append(self.msg[i, j][x_j] - old_msg)

        return np.abs(delta)

    def _get_score(self):
        bs = {}
        # We can ignore the underflow here: some belief will be so polarized
        # that p(s) â‰ˆ 0. It makes sense, and is what we desire: certainty.
        with np.errstate(under='ignore'):
            for i in self.graph.nodes:
                bs[i] = {}
                b_i = {}
                ns = self.graph.neighbors(i)
                for x_i in self.domain:
                    b_i[x_i] = self.h[i][x_i]
                    b_i[x_i] *= np.product([self.msg[k, i][x_i] for k in ns])

                norm = sum(b_i.values())
                for x_i in self.domain:
                    bs[i][x_i] = b_i[x_i] / norm

        return bs
