from collections import defaultdict

import networkx as nx
import numpy as np


class LoopyBP:
    def __init__(self, graph, p_matrix, prior, domain):
        self.graph = graph
        self.P = p_matrix
        self.h = prior
        self.domain = domain
        self.msg = defaultdict(lambda: {s: 1 for s in domain})

    def run(self, root=None, tol=.001):
        if root is None:
            root = nx.center(self.graph)[0]

        bfs_edges = list(nx.bfs_edges(self.graph, root))

        err = np.inf
        while err > tol:
            err = 0

            for (i, j) in self.graph.edges:
                deltas = self._update_msgs(i, j)
                err = max(err, *deltas)

            for (i, j) in self.graph.edges:
                deltas = self._update_msgs(j, i)
                err = max(err, *deltas)

            # # Backward
            # for (i, j) in reversed(bfs_edges):
            #     deltas = self._update_msgs(j, i)
            #     err = max(err, *deltas)

            # # Forward
            # for (i, j) in bfs_edges:
            #     deltas = self._update_msgs(i, j)
            #     err = max(err, *deltas)

        return self._calculate_beliefs()

    def _compute_msg(self, i, j, x_j):
        ns = {*list(self.graph.neighbors(i))} - {j}  # neighbors except j
        msg = 0.
        for x_i in self.domain:
            h = self.h[i][x_i] * np.product([self.msg[k, i][x_i] for k in ns])
            msg += self.P[x_i, x_j] * h

        return msg

    def _update_msgs(self, i, j):
        msgs = {}
        for x_j in self.domain:
            msgs[x_j] = self._compute_msg(i, j, x_j)

        norm = sum(msgs.values()) / len(self.domain)
        delta = []
        for x_j in self.domain:
            old_msg = self.msg[i, j][x_j]
            self.msg[i, j][x_j] = msgs[x_j] / norm
            delta.append(self.msg[i, j][x_j] - old_msg)

        return np.abs(delta)

    def _calculate_beliefs(self):
        bs = {}
        # We can ignore the underflow here: some belief will be so polarized
        # that p(s) â‰ˆ 0. It makes sense, and is what we desire: certainty.
        with np.errstate(under='ignore'):
            for i in self.graph.nodes:
                bs[i] = {}
                b_i = {}
                ns = self.graph.neighbors(i)
                for x_i in self.domain:
                    b_i[x_i] = self.h[i][x_i]
                    b_i[x_i] *= np.product([self.msg[k, i][x_i] for k in ns])

                norm = sum(b_i.values())
                for x_i in self.domain:
                    bs[i][x_i] = b_i[x_i] / norm

        return bs
