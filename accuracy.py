import random
from math import log
from collections import defaultdict
from concurrent.futures import ProcessPoolExecutor
from functools import partial

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
from tqdm import tqdm, trange

import mlw.plot
from mlw.bp import LoopyBP
from mlw.network import InteractionNetwork as Network
from mlw.utils import generate_bipartite_scale_free_graph

plt.style.use("essay")

# %%

NUM_HOSTS = 500
NUM_DOMAINS = 1000

# Create a network.
graph = generate_bipartite_scale_free_graph(NUM_HOSTS, NUM_DOMAINS, 3)
domains = graph.nodes - hosts
hosts, domains = nx.bipartite.sets(graph)
if len(hosts) > len(domains):
    hosts, domains = domains, hosts

J = 1

network = Network(graph, hosts, domains)

# %% Generate configuration with MCMC SA.
conf, energies = network.configuration(num_malicious=20, interaction=J)

fig, ax = mlw.plot.new_plot()
ax.plot(energies)
ax.set_ylabel("System energy")
ax.set_xlabel("Simulation time")
mlw.plot.set_layout(fig, 0.4)
fig.savefig("doc/fig/mcmc.png", dpi=600)

# %%

executor = ProcessPoolExecutor()

def mean_infected(n):
    cs = []
    for _ in range(10):
        conf, _ = network.configuration(n, interaction=0.5 * log(0.75 / 0.25))
        c = 0
        for node in hosts:
            c += conf[node] == -1
        cs.append(c)

    return np.mean(cs), np.std(cs)


ns = list(range(0, len(domains), 5))
res = executor.map(mean_infected, ns)
means = []
stds = []
for m, s in tqdm(res, total=len(ns)):
    means.append(m)
    stds.append(s)

means = np.array(means)
stds = np.array(stds)

# %%

plt.style.use("essay")
fig, ax = mlw.plot.new_plot()
ax.plot(ns[:51], means)
ax.set_xlabel("Number of malicious domains")
ax.set_ylabel("Number of infected hosts")
mlw.plot.set_layout(fig, 0.4)
fig.savefig("doc/fig/transition.png", dpi=600)

# %%

num_malicious = 200
conf, _ = network.configuration(
    num_malicious, interaction=0.5 * log(0.75 / 0.25))
c = 0
for node in hosts:
    c += conf[node] == -1

c

# %% Estimate accuracy.


def estimate_accuracy(network, conf, num_known_hosts):
    """Predict states and calculates true positive and true negative rates"""
    known = random.sample(network.hosts, num_known_hosts)

    # Set the prior for observed states. Slightly positive to avoid wrong
    # detection of legit domain as malicious (false positive).
    prior = defaultdict(
        lambda: {Network.state_I: 0.45, Network.state_S: 0.55})

    # Set the prior for popular domains (top 10%).
    degrees = dict(network.graph.degree(network.domains))
    popular = sorted(degrees.keys(), key=degrees.get, reverse=True)[:100]
    max_degree = degrees[popular[0]]
    for node in popular:
        p = 1 / (1 + np.exp(- 2 * degrees[node] / max_degree))
        prior[node] = {Network.state_I: 1 - p, Network.state_S: p}

    for node in known:
        prior[node] = {Network.state_I: float(conf[node] == Network.state_I),
                       Network.state_S: float(conf[node] == Network.state_S)}

    # Interaction matrix

    def phi(x, y): return 0.85 if x == y else 0.15

    # Run the max-product belief propagation
    bp = LoopyBP(graph, phi, prior, [
                 Network.state_S, Network.state_I])

    score = bp.run(reduce_func=max, tol=1e-6)

    P = N = 0
    TP = TN = 0
    for node in network.domains:
        inferred = max(score[node].keys(), key=(
            lambda key: score[node][key]))
        if inferred == conf[node]:
            if conf[node] == Network.state_I:
                TP += 1
            else:
                TN += 1

        if conf[node] == Network.state_I:
            P += 1
        else:
            N += 1

    return TP / P, TN / N
# %%

executor = ProcessPoolExecutor()
estimator = partial(estimate_accuracy, network, conf)
ns = np.arange(0, len(hosts), 5)

r_mean_tpr = np.zeros_like(ns, dtype=np.float)
r_mean_fpr = np.zeros_like(ns, dtype=np.float)

for i, num_known in enumerate(tqdm(ns)):
    res = executor.map(estimator, [num_known] * 10)
    tprs = []
    tnrs = []
    for tpr, tnr in res:
        tprs.append(tpr)
        tnrs.append(tnr)

    r_mean_tpr[i] = np.mean(tprs)
    r_mean_fpr[i] = 1 - np.mean(tnrs)

# %%

executor = ProcessPoolExecutor()
estimator = partial(estimate_accuracy, network, conf)
ns = np.arange(0, len(hosts), 5)

mean_tpr = np.zeros_like(ns, dtype=np.float)
mean_fpr = np.zeros_like(ns, dtype=np.float)

for i, num_known in enumerate(tqdm(ns)):
    res = executor.map(estimator, [num_known] * 10)
    tprs = []
    tnrs = []
    for tpr, tnr in res:
        tprs.append(tpr)
        tnrs.append(tnr)

    mean_tpr[i] = np.mean(tprs)
    mean_fpr[i] = 1 - np.mean(tnrs)


# %%

fig, ax = mlw.plot.new_plot()
ax.plot(ns, mean_tpr, label="True Positive Rate")
ax.plot(ns, mean_fpr, label="False Positive Rate", c="#d53e4f")
ax.set_xlabel("Number of known hosts")
ax.legend()
mlw.plot.set_layout(fig, 0.5)
# fig.savefig("doc/fig/accuracy_random.png", dpi=600)


# %%















def estimate_accuracy_mcmc(network, conf, num_known_hosts):
    """Predict states and calculates true positive and true negative rates"""
    known = random.sample(network.hosts, num_known_hosts)
    fields = defaultdict(lambda: 0.5 * log(0.55 / 0.45))

    # Set the prior for popular domains (top 10%).
    degrees = dict(network.graph.degree(network.domains))
    popular = sorted(degrees.keys(), key=degrees.get, reverse=True)[:100]
    max_degree = degrees[popular[0]]
    for node in popular:
        fields[node] = degrees[node] / max_degree

    for node in known:
        fields[node] = np.inf if conf[node] == Network.state_S else -np.inf

    sim = IsingMCMC(network.graph, interaction=0.5*log(0.75/0.25),
                    fields=fields, temperature=100)
    init_states = defaultdict(lambda: random.choice([+1, -1]))
    inferred, energies = sim.run(init_states, 50)
    plt.plot(energies)
    P = N = 0
    TP = TN = 0
    for node in network.domains:
        if inferred[node] == conf[node]:
            if conf[node] == Network.state_I:
                TP += 1
            else:
                TN += 1

        if conf[node] == Network.state_I:
            P += 1
        else:
            N += 1

    return TP / P, TN / N

from mlw.mcmc import IsingMCMC
estimate_accuracy_mcmc(network, conf, 500)
